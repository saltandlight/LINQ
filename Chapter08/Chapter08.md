# Chapter08. LINQ to SQL의 고급기능🦓
- IQUeryable 인터페이스를 매핑 메타데이터와 표현식 트리와 함께 이용하는 방법으로 관계형 데이터에 LINQ to Objects의 질의 표현식을 그대로 사용하는 것에 대해 알아봄
- 알아볼 내용:
    - 고급화된 LINQ to SQL의 기능들
    - 객체의 생명주기에 대한 논의를 일정 수준 확장, 동기화나 트랜잭션
    - 어떻게 좀 더 직접적으로 DB에 접근하고 SQL Server가 제공하는 기능들의 장점을 그대로 활용할 수 있는지
    - 데이터 영역의 수준을 넘어서는 비즈니스 영역에서 미리 컴파일된 질의 표현식, 부분 클래스(partial class), 상속 다형성 등을 통해 LINQ to SQL이 가져다주는 새로운 옵션들에 대해 논의해볼 것임
    - 최종적으로 LINQ to SQL의 대안으로 떠오르고 있는 Entity Framework를 이용하여 관계형 데이터를 접근하는 방법에 대해 알아볼 것

## 8.1 동기화 다루기
- 시스템이 복수의 사용자들을 지원가능하도록 확장되기 시작하면 개발자는 두 명 이상의 사용자가 하나의 특정 레코드를 동시에 수정하려고 할 떄 발생할 수 있는 문제에 대해 조금씩 고려하기 시작해야 함
- 이런 상황에 대응하는 전략:
    - 1. 비관적 동기화: 첫 번째 사용자가 작업을 하는 동안 락을 걸어 두 번째 사용자의 작업을 제한함
    - 2. 낙관적 동기화: 두 사용자가 모두 우선 수정 가능함
        - 애플리케이션 설계자는 상황에 따라 첫 번째 사용자의 수정사항을 유지할지, 아니면 두 번째 사용자의 수정사항대로 유지할지, 아니면 두 사용자의 수정사항을 적절히 조합할지를 능동적으로 판단함
    - 이 두 가지 방식의 전략은 각각 명확하게 장단점을 가지고 있음
 
### 8.1.1 비관적 동기화
- .NET 을 사용하기 전에는 많은 애플리케이션들이 DB에 대한 여녁ㄹ상태를 유지하도록 코드를 작성했음
- 이런 설계하에서는 DB의 특정 레코드를 받아온 후 다른 사용자가 동시에 수정사항을 적용하는 것을 막기 위해서 락을 건 상태를 유지시킴

- 소규모의 윈도우 기반 애플리케이션은 비관적 동기화 시나리오하에서는 별 문제 없이 동작
- 그러나... 시스템이 더 많은 사용자를 대상으로 확대되는 경우, 비관적 동기화는 과도하게 많은 락 지속시간으로 인해 시스템 전체의 효율이 저하됨...

- And... 규모 확장성의 문제들이 나타나기 시작함
- 시스템들은 클라이언트-서버 구조에서 좀 더 배포상의 용이함을 얻기 위해 상태가 없는 웹 기반의 구조로 옮겨가게 되었음
- 상태가 없는 웹 애플리케이션들을 작성한다는 것 = 애플리케이션이 장기간의 독점상태를 유발하는 비관적 동기화에 더 이상 의존 불가능

- 비관적 동기화가 유발하는 비효율적 잠금(locking) 문제와 규모 확장성 문제를 해결하고자 하는 취지에서 .NET 프레임워크는 비연결성을 특징으로 하는 웹 기반 애플리케이션을 대상으로 설계됨
- ADO.NET 이라는 데이터를 다루는 .NET API는 테이블상에서 커서의 개념을 더 이상 사용하지 않게됨
- 결과적으로 자동으로 적용되던 비관적 동기화를 더 이상 사용하지 않게 됨
- 애플리케이션들은 아직도 "체크 아웃"이라는 플래그를 두어 동일한 레코드에 연달아 접근하려는 시도가 있다면 사용 가능하도록 설계 가능
- 그러나 사용자들이 언제 더 이상 그 레코드를 사용하지 않는지 판별하기 어려움 -> 종종 그런 플래그는 사용 후 해제가 안 되는 경우가 있었음
- 이런 문제의 예방을 위해 낙관적 동기화 모델이 비연결 기반의 환경에서 대세로 등장하기 시작함 

### 8.1.2 낙관적 동기화
- 비연결 기반의 환경에서 발생한 문제점들로 인해서 이에 대한 대체 전략으로 낙관적 동기화 모델이 사용되기 시작함
- 낙관적 동기화 모델은 아무 사용자나 그들의 사본 데이터에 수정을 가할 수 있도록 허용함
- 대신에 데이터가 저장되는 시점에 프로그램은 다른 사용자가 사용했던 값들이 수정되었는지 확인 
    - -> 만약 값들에 변화가 없었다면 그 레코드들은 잠궈지지 않은 것으로 판정 
    - -> 사용자가 저장하려던 값을 저장할 수 있게 해줌
- 만약 다른 사용자가 값에 변화를 준 상황이라면 이런 상황을 충돌이라고 함. 
    - 그리고 프로그램이 이전 사용자의 수정사항을 덮어씌우거나
    - 새로운 변화를 무시하거나
    - 다른 방법들로 변화를 병합할 지 선택해야 함

- 동기화 상태를 혹인하지 않는다면 데이터베이스에 대한 SQL 문은 다음과 같은 문법구조로 이루어져 있음
- `UPDATE TABLE SET [field = value] WHERE [Id = value].`
- 여기에 낙관적 동기화를 추가하기 위해 WHERE 절은 ID 열의 값 뿐만 아니라 각각의 열의 원래 값을 비교하도록 확장되어야 함
- [Book에 대해 낙관적 동기화를 수행하기 위한 SQL Update문]
 ```SQL
 UPDATE dbo.Book
 SET Title = @NewTitle,
   Subject = @NewSubject,
   Publisher = @NewPublisher,
   PubDate = @NewPubDate,
   Price = @NewPrice,
   PageCount = @NewPageCount,
   Isbn = @NewIsbn,
   Summary = @NewSummary,
   Notes = @NewNotes,
WHERE ID = @ID AND Title = @OldTitle AND 
-- 원래 있던 값들과 비교
   Subject = @OldSubject AND
   PUblisher = @OldPublisher AND
   PubDate = @PubDate AND
   Price = @Price AND
   PageCount = @PageCount AND
   Isbn = @OldIsdn AND
   Summary = @OldSummary AND
   Notes = @OldNotes
   RETURN @@RowCount
-- 업데이트에 성공했는가?
 ```
- 업데이트에 성공했는 지 확인하려면 업데이트 수행 이후의 데이터베이스 내의 RowCount를 세어보면 됨.
- 만약 1이 반환된다면 원래 있던 값이 변하지 않았고 업데이트가 동작했다고 할 수 있음 
- 만약 0이 반환된다면 처음 로딩된 값과 동일한 값을 가진 레코드를 찾을 수 없음 -> 데이터를 받아온 이후 업데이트하는 사이에 다른 사람이 그 데이터를 바꾸어 논 것임
- 그 시점에는 사용자에게 충돌이 있었다는 점을 통지 -> 동기화 위배상황을 적절히 처리하면 됨

- 클래스가 낙관적 동기화 모델을 다르도록 구현하는 것은 매우 쉬운 일임.
- 사실 테이블과 열 매핑 구축만으로도 낙관적 동기화 모델이 기본적으로 적용되었다고 볼 수 있음
- SubmitChanges 를 호출 시 DataContext는 자동적으로 낙관적 동기화를 사용할 것임
- 간단한 업데이트 수행을 위해 어떤 SQL이 작성되었는지 살펴보려면 다음과 같이 테이블에서 가장 비싼 책을 골라내고 그 가격을 10% 할인하려고 시도하는 경우를 고려해보자
- [LINQ to SQL을 이용한 기본적인 동기화 구현]
```C#
Ch8DataContext context = new Ch8DataContext();
Book mostExpensiveBook = (from book in context.Books
                          orderby book.Price descending
                          select book).First();
decimal discount = .1M;
mostExpensiveBook.Price -= mostExpensiveBook.Price*discount;
context.SubmitChanges();
```
- 위 코드는 책을 선택하기 위한 SQL과 업데이트하는 SQL을 나타냄
```sql
UPDATE  [dbo].[Book]
SET     [Price] = @p
FROM    [dbo].Book
WHERE   ([Title] = @p0) AND ([Subject] = @p1) AND ([Publisher] = @p2)
    AND   ([PubDate] = @p3) AND ([Price] = @p4) AND ([PageCount] = @p5)
    AND   ([Isbn] = @p6) AND ([Summary] IS NULL) AND ([Notes] IS NULL)
    AND   ([ID] = @p7)
```
- DataContext에 Submitchanges가 호출되면 Update문이 자동으로 생성되어 서버에서 수행됨
- WHERE절에 전달된 이전 값을 기준으로 이들 값과 일치하는 레코드가 없다면 DataContext는 이 문장이 어떤 레코드도 수정하지 않는다는 것을 알게 될 것임
- 어떠한 레코드도 영향을 받지 않는 경우에는 ChangeConflictException 예외가 발생함

- 상황에 따라 낙관적 동기화를 구현하기 위해 필요한 매개변수의 개수가 성능상의 문제를 야기할 수도 있음(개수가 너무 많아서...)
- 그런 경우에는, 매핑을 보다 세밀하게 조정하여 값이 변하지 않았음을 확인하는 데 필요한 최소한의 필드들을 구분 가능
- UpdateCheck 속성을 설정하면 됨
    - UpdateCheck는 LINQ to SQL이 항상 열을 낙관적 동기화를 위해 체크하고 있다는 의미에서 Always로 설정되어 있음
    - 원한다면 값이 변했을 때에만(WhenChanged), 또는 절대 체크 안 되도록(Never)로 설정 가능함

- 만약 UpdateCheck 속성의 강력함을 활용하여 테이블 스키마를 변경하고 싶다면, RowVersion 또는 TimeStamp 열을 각 테이블에 추가하면 됨
- DB는 자동적으로 행에 변화가 생길 떄마다 RowVersion을 자동으로 업데이트할 것임
- 동기화 체크는 버전과 ID 열의 조합에 대해서만 이루어지면 될 것임
- 모든 다른 열은 UpdateCheck=Never로 설정되고 DB는 동기화 체크에 의해 보조될 것임
- 이런 경우는 Author 클래스를 매핑하는 데 사용한 적이 있음
- Update문을 살펴보면 TimeStamp열을 이용하여 효율화된 WHERE절을 볼 수 있음
- [타임스탬프 열을 이용하여 Authors 테이블에 낙관적 동기화를 적용하기]
```C#
Ch8DataContext context = new Ch8DataContext();
Author authorToChange = (context.Authors).First();

authorToChange.FirstName = "Jim";
authorToChange.LastName = "Wooley";

context.SubmitChanges();
```
- 이 문장은 다음과 같은 SQL로 변환됨
```SQL
UPDATE  [dbo].[Author]
SET     [LastName] = @p2, [FirstName] = @p3
FROM    [dbo].[Author]
WHERE   ([ID] = @p0) AND ([TimeStamp] = @p1)

SELECT  [t1].[TimeStamp]
FROM    [dbo].[Author] AS [t1]
WHERE   ((@ROWCOUNT) > 0) AND ([t1].[ID] = @p4)
```
- 표준적인 낙관적 동기화를 모든 필드가 항상 체크하도록 또는 타임스탬프를 이용하는 형태로 수정하는 방법 외에도 다른 동기화 모델이 존재함
    - 1. 동시에 일어나는 모든 변화를 무시하고 항상 마지막 변경사항만 남기도록 하는 것
        - 그런 경우에는 UpdateCheck는 모든 속성에 대해 Never로 설정되어 있어야 함
        - 그러나 동기화가 전혀 필요 없다고 단언할 수 있는 상황이 아닌 이상 이 방법은 그다지 추천할 만한 좋은 선택이 아님
    - 2. 최고의 선택: 사용자에게 충돌이 있었다는 점을 통지, 그 상황을 잘 봉합하기 위한 대안을 제시해주는 것

- 경우에 따라서 두 사용자가 하나의 테이블 내의 다른 두 개의 열을 동시에 수정할 수 있게 하는 것은 별 문제가 없을 수도 있음
- 예) 열이 아주 많은 테이블에서 각각 다른 열들의 집합을 다른 객체나 문맥, 상황에서 다루려고 하는 경우에는 UpdateCheck를 Always 보다는 WhenChanged로 설정함 
- 그러나 이것이 모든 경우에 사용하도록 추천할 수 있는 방법은 아님
- 여러 개의 필드가 연산된 결과물의 기반자료가 되는 경우에는 더욱 그러함
- 예를 들어 일반적인 OrderDetail테이블에서 단가나 개수에 수정을 한다면 총계 또한 변해야 함
- 하나의 사용자가 개수를 수정하는 동안 다른 사용자가 단가를 수정한다면 총계의 계산이 이상해질 것..!
    - 이런 이유로 자동병합 동기화 관리는 필요하며 실무상황에서 그런 관리가 허용 가능한지는 반드시 확인해야 함

- LINQ to SQL에서 동기화 확인은 필드 수준에서 이루어질 수 있음
- LINQ to SQL은 여러 사용자 정의형태의 구현물이 존재할 수 있는 유연함을 충분히 제공하고 있음
- 아무런 설정을 해주지 않았을 때는 기본적으로 완전히 낙관적인 동기화를 지원함

### 8.1.3 동기화 예외사항을 처리하기

### 8.1.4 트랜잭션을 이용하여 충돌을 해결하기



## 8.2 고급 데이터베이스 기능

### 8.2.1 SQL 전달 : SQL 질의에서 객체를 반환하기

### 8.2.2 저장된 프로시저와 작업하기

### 8.2.3 사용자 정의 함수


## 8.3 비즈니스 계층을 개선하기

### 8.3.1 컴파일된 질의

### 8.3.2 사용자 정의 비즈니스 로직을 위한 부분 클래스

### 8.3.3 부분 메소드의 장점들을 활용하기

### 8.3.4 객체 상속을 이용하기

## 8.4 LINQ to Entities로 잠시 눈길을 돌리기
