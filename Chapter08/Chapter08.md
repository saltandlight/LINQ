# Chapter08. LINQ to SQL의 고급기능🦓
- IQUeryable 인터페이스를 매핑 메타데이터와 표현식 트리와 함께 이용하는 방법으로 관계형 데이터에 LINQ to Objects의 질의 표현식을 그대로 사용하는 것에 대해 알아봄
- 알아볼 내용:
    - 고급화된 LINQ to SQL의 기능들
    - 객체의 생명주기에 대한 논의를 일정 수준 확장, 동기화나 트랜잭션
    - 어떻게 좀 더 직접적으로 DB에 접근하고 SQL Server가 제공하는 기능들의 장점을 그대로 활용할 수 있는지
    - 데이터 영역의 수준을 넘어서는 비즈니스 영역에서 미리 컴파일된 질의 표현식, 부분 클래스(partial class), 상속 다형성 등을 통해 LINQ to SQL이 가져다주는 새로운 옵션들에 대해 논의해볼 것임
    - 최종적으로 LINQ to SQL의 대안으로 떠오르고 있는 Entity Framework를 이용하여 관계형 데이터를 접근하는 방법에 대해 알아볼 것

## 8.1 동기화 다루기
- 시스템이 복수의 사용자들을 지원가능하도록 확장되기 시작하면 개발자는 두 명 이상의 사용자가 하나의 특정 레코드를 동시에 수정하려고 할 떄 발생할 수 있는 문제에 대해 조금씩 고려하기 시작해야 함
- 이런 상황에 대응하는 전략:
    - 1. 비관적 동기화: 첫 번째 사용자가 작업을 하는 동안 락을 걸어 두 번째 사용자의 작업을 제한함
    - 2. 낙관적 동기화: 두 사용자가 모두 우선 수정 가능함
        - 애플리케이션 설계자는 상황에 따라 첫 번째 사용자의 수정사항을 유지할지, 아니면 두 번째 사용자의 수정사항대로 유지할지, 아니면 두 사용자의 수정사항을 적절히 조합할지를 능동적으로 판단함
    - 이 두 가지 방식의 전략은 각각 명확하게 장단점을 가지고 있음
 
### 8.1.1 비관적 동기화
- .NET 을 사용하기 전에는 많은 애플리케이션들이 DB에 대한 여녁ㄹ상태를 유지하도록 코드를 작성했음
- 이런 설계하에서는 DB의 특정 레코드를 받아온 후 다른 사용자가 동시에 수정사항을 적용하는 것을 막기 위해서 락을 건 상태를 유지시킴

- 소규모의 윈도우 기반 애플리케이션은 비관적 동기화 시나리오하에서는 별 문제 없이 동작
- 그러나... 시스템이 더 많은 사용자를 대상으로 확대되는 경우, 비관적 동기화는 과도하게 많은 락 지속시간으로 인해 시스템 전체의 효율이 저하됨...

- And... 규모 확장성의 문제들이 나타나기 시작함
- 시스템들은 클라이언트-서버 구조에서 좀 더 배포상의 용이함을 얻기 위해 상태가 없는 웹 기반의 구조로 옮겨가게 되었음
- 상태가 없는 웹 애플리케이션들을 작성한다는 것 = 애플리케이션이 장기간의 독점상태를 유발하는 비관적 동기화에 더 이상 의존 불가능

- 비관적 동기화가 유발하는 비효율적 잠금(locking) 문제와 규모 확장성 문제를 해결하고자 하는 취지에서 .NET 프레임워크는 비연결성을 특징으로 하는 웹 기반 애플리케이션을 대상으로 설계됨
- ADO.NET 이라는 데이터를 다루는 .NET API는 테이블상에서 커서의 개념을 더 이상 사용하지 않게됨
- 결과적으로 자동으로 적용되던 비관적 동기화를 더 이상 사용하지 않게 됨
- 애플리케이션들은 아직도 "체크 아웃"이라는 플래그를 두어 동일한 레코드에 연달아 접근하려는 시도가 있다면 사용 가능하도록 설계 가능
- 그러나 사용자들이 언제 더 이상 그 레코드를 사용하지 않는지 판별하기 어려움 -> 종종 그런 플래그는 사용 후 해제가 안 되는 경우가 있었음
- 이런 문제의 예방을 위해 낙관적 동기화 모델이 비연결 기반의 환경에서 대세로 등장하기 시작함 

### 8.1.2 낙관적 동기화
- 비연결 기반의 환경에서 발생한 문제점들로 인해서 이에 대한 대체 전략으로 낙관적 동기화 모델이 사용되기 시작함
- 낙관적 동기화 모델은 아무 사용자나 그들의 사본 데이터에 수정을 가할 수 있도록 허용함
- 대신에 데이터가 저장되는 시점에 프로그램은 다른 사용자가 사용했던 값들이 수정되었는지 확인 
    - -> 만약 값들에 변화가 없었다면 그 레코드들은 잠궈지지 않은 것으로 판정 
    - -> 사용자가 저장하려던 값을 저장할 수 있게 해줌
- 만약 다른 사용자가 값에 변화를 준 상황이라면 이런 상황을 충돌이라고 함. 
    - 그리고 프로그램이 이전 사용자의 수정사항을 덮어씌우거나
    - 새로운 변화를 무시하거나
    - 다른 방법들로 변화를 병합할 지 선택해야 함

- 동기화 상태를 혹인하지 않는다면 데이터베이스에 대한 SQL 문은 다음과 같은 문법구조로 이루어져 있음
- `UPDATE TABLE SET [field = value] WHERE [Id = value].`
- 여기에 낙관적 동기화를 추가하기 위해 WHERE 절은 ID 열의 값 뿐만 아니라 각각의 열의 원래 값을 비교하도록 확장되어야 함
- [Book에 대해 낙관적 동기화를 수행하기 위한 SQL Update문]
 ```SQL
 UPDATE dbo.Book
 SET Title = @NewTitle,
   Subject = @NewSubject,
   Publisher = @NewPublisher,
   PubDate = @NewPubDate,
   Price = @NewPrice,
   PageCount = @NewPageCount,
   Isbn = @NewIsbn,
   Summary = @NewSummary,
   Notes = @NewNotes,
WHERE ID = @ID AND Title = @OldTitle AND 
-- 원래 있던 값들과 비교
   Subject = @OldSubject AND
   PUblisher = @OldPublisher AND
   PubDate = @PubDate AND
   Price = @Price AND
   PageCount = @PageCount AND
   Isbn = @OldIsdn AND
   Summary = @OldSummary AND
   Notes = @OldNotes
   RETURN @@RowCount
 ```
- 업데이트에 성공했는 지 확인하려면 업데이트 수행 이후의 데이터베이스 내의 RowCount를 세어보면 됨.
- 만약 1이 반환된다면 원래 있던 값이 변하지 않았고 업데이트가 동작했다고 할 수 있음 

### 8.1.3 동기화 예외사항을 처리하기

### 8.1.4 트랜잭션을 이용하여 충돌을 해결하기



## 8.2 고급 데이터베이스 기능

### 8.2.1 SQL 전달 : SQL 질의에서 객체를 반환하기

### 8.2.2 저장된 프로시저와 작업하기

### 8.2.3 사용자 정의 함수


## 8.3 비즈니스 계층을 개선하기

### 8.3.1 컴파일된 질의

### 8.3.2 사용자 정의 비즈니스 로직을 위한 부분 클래스

### 8.3.3 부분 메소드의 장점들을 활용하기

### 8.3.4 객체 상속을 이용하기

## 8.4 LINQ to Entities로 잠시 눈길을 돌리기
